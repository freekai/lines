<!DOCTYPE html>
<html>
<head>
<script type="text/javascript">
<!--
var cnvs;
var scoreBoard;

window.onload = onLoad;

function onLoad() {
    cnvs = document.getElementById("playground");
    scoreBoard = document.getElementById("score");
    initField();
    initCanvas();
    newBalls();
    cnvs.addEventListener("click", select);
    cnvs.addEventListener("doneAnimating", checkAndInsert);
    setInterval(animateSelected, 100);
    setInterval(animatePath, 100);
}

/* game.js {{{*/

var fieldSize = 9;
var field; // array, field representation
var sel; // current selection
var score = 0;

function checkAndInsert(evnt) {
    if ( ! killBalls(evnt.detail.ball.i, evnt.detail.ball.j) ) {
        if ( newBalls() < 0 ) {
            alert("you lost!");
        }
    }
}
function initField() {
    // field is a linear array of size fieldSize*fieldSize
    // position is calculated as index = x*fieldSize + y
    field = new Array(fieldSize*fieldSize);
    for (var k=0; k < fieldSize*fieldSize; k++) {
        var i, j;
        i = Math.floor(k/fieldSize);
        j = k%fieldSize;
        field[k] = {
                i: i,
                j: j,
                color: null,
                ballX: i*(cfg.cellMargin+cfg.cellSize)+cfg.cellMargin+cfg.cellSize/2,
                ballY: j*(cfg.cellMargin+cfg.cellSize)+cfg.cellMargin+cfg.cellSize/2
        };
    }
}

function newBalls() {
    // three balls at a time
    for (var i = 0; i < 3; i++) {
        var ctx;
        var rndIdx1, rndIdx2;
        var avail = field.reduce(function(x, y) { if ( ! y.color ) x.push(y); return x; }, new Array());
        var s;
        rndIdx1 = Math.floor(Math.random()*avail.length);
        s = avail[rndIdx1];
        rndIdx2 = Math.floor(Math.random()*colors.length);
        s.color = colors[rndIdx2];
        drawBall(s.ballX, s.ballY, 3/10*cfg.cellSize, s.color);
        if ( ! killBalls(s.i, s.j) ) {
            if ( avail.length == 1 ) return -1;
        }
    }
    return 0;
}

var ih; // interval handler

function select(event) {
    var x, y; // positions within the canvas
    var i, j; // matrix indices of the cell

    x = event.pageX + ( window.pageXScroll ? window.pageXScroll : 0 ) - cnvs.offsetLeft;
    y = event.pageY + ( window.pageYScroll ? window.pageYScroll : 0 ) - cnvs.offsetTop;

    // NB: is not worth a separate function
    i = Math.floor(x/(cfg.cellSize+cfg.cellMargin));
    j = Math.floor(y/(cfg.cellSize+cfg.cellMargin));

    if ( ! sel ) {
        // no selection. simply change selection to the picked cell if the ball
        // is there
        if ( field[idx(i,j)].color ) {
            sel = field[idx(i,j)];
            return;
        }
    } else {
        var path = null;
        if ( field[idx(i, j)].color ) { // if other ball is selected, redraw the
                                        // ball and change selection
            eraseCell(sel.i, sel.j);
            drawBall(sel.ballX, sel.ballY, 3/10*cfg.cellSize, sel.color);
            sel = field[idx(i, j)];
            return;
        }
        if ( (path = findPath(sel.i, sel.j, i, j)) ) {
            moveBall(sel.i, sel.j, path);
            sel = null;
        } else {
            alert("cannot find path");
        }
    }
}

// shift from the current (i, j) to get to the neighbors
var _neighbors = [[-1, 0], [0, -1], [1, 0], [0, 1]];

// simple Dijkstra's algorithm implementation
// TODO: inefficient minDist -- requires walk though entire graph
// TODO: inefficient reduce -- might not be even needed, other conditions within
// the cycle will be satisfied sooner
function findPath(ib, jb, ie, je) {
    var graph = new Array(fieldSize*fieldSize);
    var path = new Array();
    var length;
    for (var k=0; k < fieldSize*fieldSize; k++) {
        graph[k] = { incl: 1, dist: Number.MAX_VALUE, prev: -1 };
    }
    graph[idx(ib, jb)].dist = 0;

    var minIdx = -1; 
    while ( graph.reduce(function(x, y) { return ( y.incl ) ? x+1 : x}, 0) ) {
        minIdx = minDist(ib, jb, graph);
        var imin = Math.floor(minIdx/fieldSize);
        var jmin = minIdx%fieldSize;
        if ( minIdx < 0 ) break;
        graph[minIdx].incl = 0;
        if ( imin == ie && jmin == je ) break;
        if ( graph[minIdx].dist == Number.MAX_VALUE ) break;
        for (var k in _neighbors) {
            var ic, jc; // i and j of each neighbor
            var alt;
            ic = imin+_neighbors[k][0];
            jc = jmin+_neighbors[k][1];
            if ( ! isInside(ic, jc) ) continue;
            if ( field[idx(ic, jc)].color ) continue;
            if ( ! graph[idx(ic, jc)] ) continue;
            
            alt = graph[minIdx].dist + 1;
            if ( alt < graph[idx(ic, jc)].dist ) {
                graph[idx(ic, jc)].dist = alt;
                graph[idx(ic, jc)].prev = minIdx;
            }
        }
    }
    var k = minIdx;
    if ( k < 0 ) return null; // path has not been found
    while ( graph[k].prev >= 0 ) {
        path.push(field[k]);
        k = graph[k].prev;
    }
    return path;
}

function minDist(i, j, graph) {
    var min = Number.MAX_VALUE;
    var minIdx = -1;
    for (var k=0; k < fieldSize*fieldSize; k++) {
        if ( ! graph[k].incl ) continue;
        if ( graph[k].dist < min ) {
            min = graph[k].dist;
            minIdx = k;
        }
    }
    return minIdx;
}

function moveBall(i, j, path) {
    var ctx = cnvs.getContext("2d");
    var start = field[idx(i, j)];
    var color = start.color;
    var h;
    var dest = path[0];
    start.color = null;
    eraseCell(i, j);
    dest.color = color;
    drawBall(dest.ballX, dest.ballY, 3/10*cfg.cellSize, color);
    path.push(start);
    animPathState.r = Math.floor(3/10*cfg.cellSize/2); 
    animPathState.path = path;
    animPathState.color = color;
    animPathState.stop = false;
}

var _line_directions = [[1, -1], [1, 1], [1, 0], [0, 1]];

function killBalls(i, j) {
    var pt = field[idx(i, j)]; // what we just moved/inserted
    var line = new Array(); 
    var killed = 0;
    line.push(pt);
    var ic, jc; // current ball index
    for (var k in _line_directions) { // over 4 possible directions
        di = _line_directions[k][0];
        dj = _line_directions[k][1];
        ic = pt.i + di;
        jc = pt.j + dj;
        while ( isInside(ic, jc) && field[idx(ic, jc)].color == pt.color ) {
            line.push(field[idx(ic, jc)]); 
            ic += di;
            jc += dj;
        }
        // reverse direction
        ic = pt.i - di;
        jc = pt.j - dj;
        while ( isInside(ic, jc) && field[idx(ic, jc)].color == pt.color ) {
            line.push(field[idx(ic, jc)]);
            ic -= di;
            jc -= dj;
        }
        if ( line.length > 4 ) { // got line
            // TODO: calculate scores and everything
            // sort and kill
            var origin = line.shift();
            var lineSorted = line.sort(function(x, y) { return ( y.i-x.i ) ? y.i-x.i : (y.j-x.j); });
            for (var b in lineSorted) {
                lineSorted[b].color = null;
                eraseCell(lineSorted[b].i, lineSorted[b].j);
                killed++;
            }
            line.unshift(origin);
            line.length = 1; // truncate
        } else {
            line.length = 1; // truncate
        }
    }
    if ( killed ) { // we have origin left at the beginning of the array
        line[0].color = null;
        eraseCell(line[0].i, line[0].j);
        killed++;
        
        // update score
        // calculated as 10 for 5 balls, for more: 2*killed+(2*(killed-6)+1)
        if ( killed == 5 ) score += 10;
        else score += 2*killed+2*(killed-6)+1;
        updateScoreBoard();
    }
    return killed;
}

function isInside(i, j) {
    return ( ( i >= 0 ) && ( i < fieldSize ) )
        && ( ( j >= 0 ) && ( j < fieldSize ) );
}

function idx(i, j) {
    return i*fieldSize+j;
}
/* }}} */

/* draw.js {{{ */

var colors = [
    "#e50909", // red
    "#04e007", // green
    "#050985", // blue
    "#2c2c2c", // black
    "#ff8040", // orange
    "#b9005c", // magenta
    "#17c6c6"  // lightblue
];

var cfg = {
    cellSize: 50,
    cellMargin: 3
};


function initCanvas() {
    // calculate size
    var ctx;
    var size = fieldSize * (cfg.cellSize + cfg.cellMargin) + cfg.cellMargin*1.5;
    cnvs.width = size;
    cnvs.height = size;
    ctx = cnvs.getContext("2d");
    ctx.fillStyle = "#ddd";
    ctx.fillRect(0, 0, size, size);
    drawField();
}

function drawField() {
    var ctx;
    var grad;
    if ( ! cnvs ) {
        return;
    }
    ctx = cnvs.getContext("2d");
    // draw the field grid
    ctx.beginPath();
    ctx.lineWidth = cfg.cellMargin;
    ctx.strokeStyle = "#eee";
    ctx.shadowColor = "#999";
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = cfg.cellMargin/2;
    for (var i=0, offset=2; i < fieldSize+1; i++, offset+=cfg.cellMargin+cfg.cellSize) {
        ctx.moveTo(0, offset);
        ctx.lineTo(cnvs.width, offset);
        ctx.stroke();
    }
    ctx.shadowOffsetX = cfg.cellMargin/2;
    ctx.shadowOffsetY = 0;
    for (var i=0, offset=2; i < fieldSize+1; i++, offset+=cfg.cellMargin+cfg.cellSize) {
        ctx.moveTo(offset, 0);
        ctx.lineTo(offset, cnvs.height);
        ctx.stroke();
    }
    ctx.closePath();
    // final touch -- the rightmost border and the bottom one
    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.strokeStyle = "#999";
    ctx.moveTo(0, cnvs.height-cfg.cellMargin/4);
    ctx.lineTo(cnvs.width, cnvs.height-cfg.cellMargin/4);
    ctx.stroke();
    ctx.moveTo(cnvs.width-cfg.cellMargin/4, 0);
    ctx.lineTo(cnvs.width-cfg.cellMargin/4, cnvs.height-cfg.cellMargin/4);
    ctx.stroke();
    ctx.closePath();
}

function drawBall(x, y, r, color) {
    var ctx = cnvs.getContext("2d");
    var grd = ctx.createRadialGradient(x-r*.2, y-r*.2, 0, x-r*.2, y-r*.2, r/2);
    grd.addColorStop(.0, "#f5f5f5");
    grd.addColorStop(1.0, color);
    ctx.shadowOffsetX = r*.1;
    ctx.shadowOffsetY = r*.1;
    ctx.shadowBlur = r*.1;
    ctx.strokeStyle = color;
    ctx.fillStyle = grd;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.closePath();
}

function eraseCell(i, j) {
    var cell = field[idx(i, j)];
    var ctx = cnvs.getContext("2d");
    var x, y;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.shadowBlur = 0;
    ctx.strokeStyle = "#ddd";
    ctx.fillStyle = "#ddd";
    ctx.lineWidth = 0;
    ctx.beginPath();
    ctx.arc(cell.ballX, cell.ballY, cfg.cellSize/2-cfg.cellMargin-1, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.closePath();
}

var animPathState = {
    r: 0,
    path: null,
    color: null,
    stop: true
};

var evnt = new CustomEvent(
        "doneAnimating", 
        {
            detail: {
                ball: null
            },
            bubbles: true,
            cancelable: true
        }
);

function animatePath() {
    var r = --animPathState.r;
    var cpath = animPathState.path;
    var color = animPathState.color;
    if ( r < 0 && r+2 > 0 ) {
        if ( cpath && cpath[0] ) {
            evnt.detail.ball = cpath[0];
            cnvs.dispatchEvent(evnt);
            for (var k=1; k < cpath.length; k++) {
                var c = cpath[k];
                if ( ! c.color ) {
                    eraseCell(c.i, c.j);
                }
            }
        }
    } else if ( r > 0 ) {
        for (var k=1; k < cpath.length; k++) {
            var c = cpath[k];
            if ( ! c.color ) {
                eraseCell(c.i, c.j);
                drawBall(c.ballX, c.ballY, animPathState.r, color);
            }
        }
    }
}

var animSelState = {
    ch: 0,
    dir: -1
};

function animateSelected() {
    var cell = sel;
    var ctx;
    var height;
    var dir = -1;
    var ch = animSelState.ch; // current height
    var x, y;
    var r  = 3/10*cfg.cellSize;
    if ( ! cell ) return;
    height = Math.floor(5*r/12);
    x = cell.ballX;
    y = cell.ballY;

    eraseCell(cell.i, cell.j);
    ctx = cnvs.getContext("2d");
    ch++;
    if ( ch == height ) {
        ch = 0;
        dir *= -1;
    }
    animSelState.ch = ch;
    animSelState.dir = dir;
    y += ch*dir;
    var grd = ctx.createRadialGradient(x-r*.2, y-r*.2, 0, x-r*.2, y-r*.2, r/2);
    grd.addColorStop(.0, "#f5f5f5");
    grd.addColorStop(1.0, cell.color);
    ctx.shadowOffsetX = r*.1;
    ctx.shadowOffsetY = r*.1+ch;
    ctx.shadowBlur = r*.1;
    ctx.strokeStyle = cell.color;
    ctx.fillStyle = grd;
    ctx.lineWidth = 0;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.closePath();
}

function updateScoreBoard() {
    scoreBoard.innerHTML = score;
}

/* }}} */

-->
</script>
<style>
a.scoreboard, a {
    background-color: #666;
    color: white;
    font-family: Lucida Console, monospace;
    font-weight: bold;
    font-size: 16px;
    padding: 10px;
}
a.scoreboard {
    border-radius: 6px 0px 0px 6px;
}
a {
    border-radius: 0px 6px 6px 0px;
}
</style>
<title>Lines (pure HTML5 game, canvas+js, no static images)</title>
</head>
<body bgcolor="#f0f0f0">
<div style="text-align: center; vertical-align: center; margin:10px" width="100%" height="100%">
<canvas id="playground"></canvas>
<p>
<a width="10%" class="scoreboard">Score: <a id="score">0</a></p>
</div>
</body>
</html>
